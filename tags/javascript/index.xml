<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on Today I Learned</title>
    <link>https://haleyjung.github.io/tags/javascript/</link>
    <description>Recent content in JavaScript on Today I Learned</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 13 Feb 2022 16:52:11 -0500</lastBuildDate><atom:link href="https://haleyjung.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Memory Management of Primitives vs. References</title>
      <link>https://haleyjung.github.io/posts/2022/02/memory-management-of-primitives-vs.-references/</link>
      <pubDate>Sun, 13 Feb 2022 16:52:11 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/memory-management-of-primitives-vs.-references/</guid>
      <description>Define Primitives: number, string, Boolean, undefined, null, symbol and BigInt.
References: objects (object literal, arrays, functions)
Memory Management JavaScript engine has two components:
 The call stack where functions are executed  All primitive types are stored in the call stack, as that&amp;rsquo;s where the execution context runs.   The heap where objects are stored in memory  All reference types (object) get stored in the memory heap.    The Process: Primitive Types in Call Stack let age = 30; let oldAge = age; age = 31;  let age = 30;:  JavaScript engine creates a unique identifier with the variable name.</description>
    </item>
    
    <item>
      <title>JavaScript Revision 3</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-3/</link>
      <pubDate>Thu, 10 Feb 2022 08:07:05 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-3/</guid>
      <description>1. Fundamental Concept Value
 JavaScript has the scalar primitive types that are passed by value: Number, String, Boolean, undefined, null, and Symbol Values are stored in variables, a named unit of data  Reference
 JavaScript has 3 data types that are passed by reference: Array, Function, and Objcet These are collectively known as Objects.    2. Higher Order Functions / Callback Functions Higher Order Function
 A function that accepts functions as parameters and/or returns a function.</description>
    </item>
    
    <item>
      <title>JavaScript Revision 2</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-2/</link>
      <pubDate>Thu, 10 Feb 2022 00:01:54 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-2/</guid>
      <description>Term Definition     Execution context Holds information about the environment within which the current code is being executed; Calling a function creates a new execution context. An execution context always contains 3 parts: a variable environment, the scope chain in the current context, and this keyword.   Call Stack Where execution contexts get stacked on top of each other to keep track of where we are in the program’s execution.</description>
    </item>
    
    <item>
      <title>JavaScript Revision 1</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-1/</link>
      <pubDate>Wed, 09 Feb 2022 22:17:53 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-1/</guid>
      <description>Term Definition     Value JavaScript has the scalar primitive types that are passed by value: Number, String, Boolean, undefined, null, Symbol, and BigInt   Reference JavaScript has 3 data types that are passed by reference: Array, Function, and Objcet   Variable A named unit of data where values can be stored and referred to by that name   Function The primary method through which we manipulate data in JavaScript.</description>
    </item>
    
    <item>
      <title>High Level Overview (2)</title>
      <link>https://haleyjung.github.io/posts/2022/02/high-level-overview-2/</link>
      <pubDate>Tue, 08 Feb 2022 00:02:45 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/high-level-overview-2/</guid>
      <description>The Engine and Runtime The JavaScript engine always contains a call stack and a heap.
Call Stack JavaScript code runs in the call stack.
The call stack is where execution contexts get stacked on top of each other to keep track of where we are in the program&amp;rsquo;s execution. The execution context on top of the stack is the one that&amp;rsquo;s currently running. When it&amp;rsquo;s finished running, it will be removed from the stack, and execution will go back to the previous execution context.</description>
    </item>
    
    <item>
      <title>High Level Overview (1)</title>
      <link>https://haleyjung.github.io/posts/2022/02/high-level-overview-1/</link>
      <pubDate>Mon, 07 Feb 2022 17:21:33 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/high-level-overview-1/</guid>
      <description>High-level languages, such as JavaScript and Python, have abstractions so that we don&amp;rsquo;t need to manage resources (i.e. memory/CPU) like we do for low level languages like C.
Garbage Collection One of the powerful tools in JavaScript that takes away the memory management from developers is garbage collection. It&amp;rsquo;s an algorithm inside the JavaScript engine that automatically removes old and unused objects from the computer memory.
Interpreted / Just-in-time Compiled Language The JavaScript code we write is a human-readable abstraction over machine code, which needs to be compiled/interpreted to machine code that is understood by the computer&amp;rsquo;s processor (only zeros and ones!</description>
    </item>
    
    <item>
      <title>Node.js: Content Types</title>
      <link>https://haleyjung.github.io/posts/2022/02/node.js-content-types/</link>
      <pubDate>Tue, 01 Feb 2022 01:30:17 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/node.js-content-types/</guid>
      <description>JSON: JavaScript Object Notation JSON, or JavaScript Object Notation, is a minimal, readable format for structuring data. It is used primarily to transmit data between a server and web application, as an alternative to XML.
JSON can be parsed by a standard JavaScript function, and is parsed into a ready-to-use JavaScript object. It is thus faster and easier than XML.
To read from JSON, we need to first use fs to read in the file as text(strings) and then `JOSN.</description>
    </item>
    
    <item>
      <title>Node / Node.JS</title>
      <link>https://haleyjung.github.io/posts/2022/01/node-/-node.js/</link>
      <pubDate>Mon, 31 Jan 2022 10:35:53 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/01/node-/-node.js/</guid>
      <description>What is Node? Nodes in the DOM are elements from the HTML page, which are organized in a hiearchical tree-like structure consisting of parents and children. Elements such as &amp;lt;p&amp;gt;, &amp;lt;div&amp;gt;, &amp;lt;section&amp;gt; are considered as &amp;ldquo;element&amp;rdquo; nodes while comments are &amp;ldquo;comment&amp;rdquo; nodes, &amp;ldquo;text&amp;rdquo; objects and line-breaks are &amp;ldquo;text&amp;rdquo; nodes. Every HTML element is a node, but not every node is an HTML element.
The topmost node is the root node of the DOM tree, Document, which has two children: &amp;lt;!</description>
    </item>
    
    <item>
      <title>Recursion</title>
      <link>https://haleyjung.github.io/posts/2022/01/recursion/</link>
      <pubDate>Sun, 30 Jan 2022 01:12:59 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/01/recursion/</guid>
      <description>Definition Recursion is a technique for solving problems wherein a function makes calls to itself. By doing so, it can complete a small amount of the processing, and delegate the rest of the problem to the recursive calls.
Recursive function always come with a function inside. With 2 minimum cases inside: a base case, and a recursive case. The base case is the situation or condition where we don&amp;rsquo;t need to recursively invoke the function and is safe to assume that that function can end easily.</description>
    </item>
    
    <item>
      <title>Prototype &amp; Class Patterns</title>
      <link>https://haleyjung.github.io/posts/2022/01/prototype-class-patterns/</link>
      <pubDate>Thu, 27 Jan 2022 07:29:36 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/01/prototype-class-patterns/</guid>
      <description>Prototype Chains JavaScript has only one constructor, objects.
Each object has a private property which holds a link to another object called prototype.
 i.e. JavaScript objects have a link to a prototype object.
 The prototype object has a prototype of its own, and so on until the object is reached with null as its prototype (i.e. no prototype). This acts as the final link in the prototype chain.</description>
    </item>
    
  </channel>
</rss>
