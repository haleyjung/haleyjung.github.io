<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Today I Learned</title>
    <link>https://haleyjung.github.io/</link>
    <description>Recent content on Today I Learned</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 15 Feb 2022 00:03:42 -0500</lastBuildDate><atom:link href="https://haleyjung.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Promises</title>
      <link>https://haleyjung.github.io/posts/2022/02/promises/</link>
      <pubDate>Tue, 15 Feb 2022 00:03:42 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/promises/</guid>
      <description>Promise  Promise is an object that returns a value in the future. It represents the an eventual completion or failures of an asynchronous operation. If a function cannot return a value or throw an exception without blocking, it can return a promise instead. Use promise whenever we are using async or blocking code. There are 3 PromiseStates: pending, fulfilled, and rejected  For multiple operations, after each promise has either resolved for rejected, we enter the pending state of the next promise in the chain.</description>
    </item>
    
    <item>
      <title>Asynchronous vs Synchronous Programming</title>
      <link>https://haleyjung.github.io/posts/2022/02/asynchronous-vs-synchronous-programming/</link>
      <pubDate>Mon, 14 Feb 2022 01:08:55 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/asynchronous-vs-synchronous-programming/</guid>
      <description>By default, JavaScript is a** synchronous, blocking, single-threaded** language
  Synchronous: executing one thing at a time Single-threaded: executing the code line by line  Issue of Being Synchronous When we are working on a big application with a lot of server requests, being synchronous will slow down the application.
console.log(&amp;#34;Start&amp;#34;) for (let i = 0; i &amp;lt; 20; i++) { console.log(i) } console.log(&amp;#34;End&amp;#34;) /* Start 0 1 2 3 4 .</description>
    </item>
    
    <item>
      <title>Memory Management of Primitives vs. References</title>
      <link>https://haleyjung.github.io/posts/2022/02/memory-management-of-primitives-vs.-references/</link>
      <pubDate>Sun, 13 Feb 2022 16:52:11 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/memory-management-of-primitives-vs.-references/</guid>
      <description>Define Primitives: number, string, Boolean, undefined, null, symbol and BigInt.
References: objects (object literal, arrays, functions)
A side note on Numbers Numbers in JavaScript are treated with a floating point precision!
Qs. What will the code below output? Explain your answer.
console.log(0.1 + 0.2); console.log(0.1 + 0.2 = 0.3); &amp;ldquo;You can&amp;rsquo;t be sure. It might print out 0.3 and true, or not. Numbers in JavaScript are all treated with floating point precision, and as much, may not always yield the expected results.</description>
    </item>
    
    <item>
      <title>LeetCode: Add Two Numbers - medium</title>
      <link>https://haleyjung.github.io/posts/2022/02/leetcode-add-two-numbers-medium/</link>
      <pubDate>Sat, 12 Feb 2022 10:46:58 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/leetcode-add-two-numbers-medium/</guid>
      <description>Prompt You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>LeetCode: Two Sums - easy</title>
      <link>https://haleyjung.github.io/posts/2022/02/leetcode-two-sums-easy/</link>
      <pubDate>Thu, 10 Feb 2022 11:35:01 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/leetcode-two-sums-easy/</guid>
      <description>Prompt Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.
Example: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>JavaScript Revision 3</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-3/</link>
      <pubDate>Thu, 10 Feb 2022 08:07:05 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-3/</guid>
      <description>1. Fundamental Concept Value
 JavaScript has the scalar primitive types that are passed by value: Number, String, Boolean, undefined, null, and Symbol Values are stored in variables, a named unit of data  Reference
 JavaScript has 3 data types that are passed by reference: Array, Function, and Objcet These are collectively known as Objects.  Hoisting
 A JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</description>
    </item>
    
    <item>
      <title>JavaScript Revision 2</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-2/</link>
      <pubDate>Thu, 10 Feb 2022 00:01:54 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-2/</guid>
      <description>Term Definition     Execution context Holds information about the environment within which the current code is being executed; Calling a function creates a new execution context. An execution context always contains 3 parts: a variable environment, the scope chain in the current context, and this keyword.   Call Stack Where execution contexts get stacked on top of each other to keep track of where we are in the programâ€™s execution.</description>
    </item>
    
    <item>
      <title>JavaScript Revision 1</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-1/</link>
      <pubDate>Wed, 09 Feb 2022 22:17:53 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-1/</guid>
      <description>Term Definition     Value JavaScript has the scalar primitive types that are passed by value: Number, String, Boolean, undefined, null, Symbol, and BigInt   Reference JavaScript has 3 data types that are passed by reference: Array, Function, and Objcet   Variable A named unit of data where values can be stored and referred to by that name   Function The primary method through which we manipulate data in JavaScript.</description>
    </item>
    
    <item>
      <title>High Level Overview (2)</title>
      <link>https://haleyjung.github.io/posts/2022/02/high-level-overview-2/</link>
      <pubDate>Tue, 08 Feb 2022 00:02:45 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/high-level-overview-2/</guid>
      <description>The Engine and Runtime The JavaScript engine always contains a call stack and a heap.
Call Stack JavaScript code runs in the call stack.
The call stack is where execution contexts get stacked on top of each other to keep track of where we are in the program&amp;rsquo;s execution. The execution context on top of the stack is the one that&amp;rsquo;s currently running. When it&amp;rsquo;s finished running, it will be removed from the stack, and execution will go back to the previous execution context.</description>
    </item>
    
    <item>
      <title>High Level Overview (1)</title>
      <link>https://haleyjung.github.io/posts/2022/02/high-level-overview-1/</link>
      <pubDate>Mon, 07 Feb 2022 17:21:33 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/high-level-overview-1/</guid>
      <description>High-level languages, such as JavaScript and Python, have abstractions so that we don&amp;rsquo;t need to manage resources (i.e. memory/CPU) like we do for low level languages like C.
Garbage Collection One of the powerful tools in JavaScript that takes away the memory management from developers is garbage collection. It&amp;rsquo;s an algorithm inside the JavaScript engine that automatically removes old and unused objects from the computer memory.
Interpreted / Just-in-time Compiled Language The JavaScript code we write is a human-readable abstraction over machine code, which needs to be compiled/interpreted to machine code that is understood by the computer&amp;rsquo;s processor (only zeros and ones!</description>
    </item>
    
  </channel>
</rss>
