<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Today I Learned</title>
    <link>https://haleyjung.github.io/</link>
    <description>Recent content on Today I Learned</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 19 Feb 2022 18:57:18 -0500</lastBuildDate><atom:link href="https://haleyjung.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Patterns</title>
      <link>https://haleyjung.github.io/posts/2022/02/patterns/</link>
      <pubDate>Sat, 19 Feb 2022 18:57:18 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/patterns/</guid>
      <description>What is a design pattern? A design pattern names, abstracts, and identifies the key aspects of a common design structure that make it useful for creating a reusable object-oriented design.
A design pattern identifies the participatign class and their instances, their roles and collaborations, and the distribution of responsibilities.
Categorizing Patterns Creational Design Patterns  Focuses on handling object creation mechanisms By controlling the creation process, it aims to solve the problem of the basic approach to object creation adding complexity in a project   Constructor, Factory, Abstract, Prototype, Singleton, and Builder are some of the creational design patterns.</description>
    </item>
    
    <item>
      <title>Recursion Prompts</title>
      <link>https://haleyjung.github.io/posts/2022/02/recursion-prompts/</link>
      <pubDate>Thu, 17 Feb 2022 00:05:21 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/recursion-prompts/</guid>
      <description>In Progres&amp;hellip;
// Solve the following prompts using recursion.  // 1. Calculate the factorial of a number. The factorial of a non-negative integer n, // denoted by n!, is the product of all positive integers less than or equal to n. // Example: 5! = 5 x 4 x 3 x 2 x 1 = 120 // factorial(5); // 120 var factorial = function(n) { if (isNaN(n) || n &amp;lt; 0) { return null; } if (n === 0 || n === 1) { return 1; } return n * factorial(n-1); }; // 2.</description>
    </item>
    
    <item>
      <title>The Event Loop</title>
      <link>https://haleyjung.github.io/posts/2022/02/the-event-loop/</link>
      <pubDate>Wed, 16 Feb 2022 09:01:36 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/the-event-loop/</guid>
      <description>JavaScript Runtime &amp;amp; Web API console.log(&amp;#34;Start script&amp;#34;); setTimeout(() =&amp;gt; { task(&amp;#34;Download a file&amp;#34;); }, 1000); console.log(&amp;#34;Done&amp;#34;); /* output: Start script Done Download a file */  setTimeout(), fetch requests, and DOM events (such as clicking a button) are parts of the Web APIs of the web browser. These operations can be performed concurrently and asynchronously.
  When setTimeout() function is called, the JavaScript engine places it on the call stack &amp;amp; the Web API creates a timer that expires in 1 second.</description>
    </item>
    
    <item>
      <title>Promises</title>
      <link>https://haleyjung.github.io/posts/2022/02/promises/</link>
      <pubDate>Tue, 15 Feb 2022 00:03:42 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/promises/</guid>
      <description>Promise  A function operates asynchronously via an event loop An async function uses Promise to return the result   Promise is an object that returns a value in the future. It represents the an eventual completion or failures of an asynchronous operation. If a function cannot return a value or throw an exception without blocking, it can return a promise instead. Use promise whenever we are using async or blocking code.</description>
    </item>
    
    <item>
      <title>Asynchronous vs Synchronous Programming</title>
      <link>https://haleyjung.github.io/posts/2022/02/asynchronous-vs-synchronous-programming/</link>
      <pubDate>Mon, 14 Feb 2022 01:08:55 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/asynchronous-vs-synchronous-programming/</guid>
      <description>By default, JavaScript is a** synchronous, blocking, single-threaded** language
  Synchronous: executing one thing at a time Single-threaded: executing the code line by line  Issue of Being Synchronous When we are working on a big application with a lot of server requests, being synchronous will slow down the application.
console.log(&amp;#34;Start&amp;#34;) for (let i = 0; i &amp;lt; 20; i++) { console.log(i) } console.log(&amp;#34;End&amp;#34;) /* Start 0 1 2 3 4 .</description>
    </item>
    
    <item>
      <title>Memory Management of Primitives vs. References</title>
      <link>https://haleyjung.github.io/posts/2022/02/memory-management-of-primitives-vs.-references/</link>
      <pubDate>Sun, 13 Feb 2022 16:52:11 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/memory-management-of-primitives-vs.-references/</guid>
      <description>Define Primitives: number, string, Boolean, undefined, null, symbol and BigInt.
References: objects (object literal, arrays, functions)
A side note on Numbers Numbers in JavaScript are treated with a floating point precision!
Qs. What will the code below output? Explain your answer.
console.log(0.1 + 0.2); console.log(0.1 + 0.2 = 0.3); &amp;ldquo;You can&amp;rsquo;t be sure. It might print out 0.3 and true, or not. Numbers in JavaScript are all treated with floating point precision, and as much, may not always yield the expected results.</description>
    </item>
    
    <item>
      <title>LeetCode: Add Two Numbers - medium</title>
      <link>https://haleyjung.github.io/posts/2022/02/leetcode-add-two-numbers-medium/</link>
      <pubDate>Sat, 12 Feb 2022 10:46:58 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/leetcode-add-two-numbers-medium/</guid>
      <description>Prompt You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>JavaScript Revision 4: Recursion</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-4-recursion/</link>
      <pubDate>Fri, 11 Feb 2022 14:09:48 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-4-recursion/</guid>
      <description>Recursion Review üîî What is it for?  For accessing a nested data structure Particularly useful when we do not know how many levels of nested arrays/objects there are Recursion acts as a looping mechanism unto itself and leverages the callstack to complete its task  ¬†üîî How Does It Works? üåü function recurson() { // &amp;lt;-- (2) Runs this recursion function script  return ‚ö°recursion(); // &amp;lt;-- (3) Runs the inner recursion function } üåü recursion(); // &amp;lt;-- (1) Starts from the global scope  NOTE: The recursion function is executed twice: (1) ‚ö° within the scope of our fuction (2) üåüoutside in the global scope   We first execute the üåürecursion function in the global scope ‚û°Ô∏è it runs the üåürecursion function script ‚û°Ô∏è This calls the ‚ö°inner recursion function ‚û°Ô∏è The inner recursion function runs the üåürecursion function again ‚û°Ô∏è Continues, adding recursion continously to our callstack, thereby creating a loop  ¬†üîî Recursive Pattern  Base case is on the top, recursive case is below We pass different arguments to recursive functions to move around the nested object  // (1) what do you want to do for the current input?</description>
    </item>
    
    <item>
      <title>LeetCode: Two Sums - easy</title>
      <link>https://haleyjung.github.io/posts/2022/02/leetcode-two-sums-easy/</link>
      <pubDate>Thu, 10 Feb 2022 11:35:01 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/leetcode-two-sums-easy/</guid>
      <description>Prompt Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.
Example: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>JavaScript Revision 3</title>
      <link>https://haleyjung.github.io/posts/2022/02/javascript-revision-3/</link>
      <pubDate>Thu, 10 Feb 2022 08:07:05 -0500</pubDate>
      
      <guid>https://haleyjung.github.io/posts/2022/02/javascript-revision-3/</guid>
      <description>1. Fundamental Concept Value
 JavaScript has the scalar primitive types that are passed by value: Number, String, Boolean, undefined, null, and Symbol Values are stored in variables, a named unit of data  Reference
 JavaScript has 3 data types that are passed by reference: Array, Function, and Objcet These are collectively known as Objects.  Hoisting
 A JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</description>
    </item>
    
  </channel>
</rss>
